
import streamlit as st
import uuid
import time
import torch
import random
import string
import pandas as pd
from datetime import datetime
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

from model import (
    train_secret_regenerator,
    evaluate_secret_regenerator,
    add_noise_to_tensor,
    anomaly_score
)

# ======================
# Config
# ======================
st.set_page_config("WARL0K RNN + MQTT Simulation", layout="wide")
vocab = list("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")

def to_tensor(text):
    return torch.tensor([vocab.index(c) for c in text], dtype=torch.long)

def entropy(s):
    from collections import Counter
    from math import log2
    counts = Counter(s)
    probs = [v / len(s) for v in counts.values()]
    return -sum(p * log2(p) for p in probs)

# ======================
# App State
# ======================
if "model" not in st.session_state:
    st.session_state.model = None
if "sessions" not in st.session_state:
    st.session_state.sessions = []
if "history" not in st.session_state:
    st.session_state.history = pd.DataFrame(columns=["timestamp", "session_id", "entropy", "drift", "anomaly"])

# ======================
# Sidebar Controls
# ======================
st.sidebar.title("WARL0K MQTT Session Control")

if st.sidebar.button("ðŸ”„ Simulate MQTT Session"):
    session_id = str(uuid.uuid4())
    secret = ''.join(random.choices(vocab, k=16))
    model = train_secret_regenerator(secret, vocab, epochs=80)

    clean_tensor = to_tensor(secret)
    noisy = add_noise_to_tensor(clean_tensor, len(vocab), noise_level=0.3)
    regen = evaluate_secret_regenerator(model, noisy.unsqueeze(1), vocab)

    entropy_score = entropy([vocab[i] for i in noisy.tolist()])
    drift = sum(a != b for a, b in zip(secret, regen)) / len(secret)
    anomaly = anomaly_score(clean_tensor, noisy)

    st.session_state.sessions.append({
        "id": session_id,
        "secret": secret,
        "noisy": ''.join([vocab[i] for i in noisy.tolist()]),
        "regen": regen,
        "entropy": entropy_score,
        "drift": drift,
        "anomaly": anomaly
    })

    st.session_state.history.loc[len(st.session_state.history)] = {
        "timestamp": datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"),
        "session_id": session_id,
        "entropy": entropy_score,
        "drift": drift,
        "anomaly": anomaly
    }

    st.sidebar.success(f"Session {session_id} simulated with latency")
    time.sleep(random.uniform(0.3, 1.0))  # simulate network delay

# ======================
# Session Details
# ======================
st.title("ðŸ“¡ WARL0K MQTT Session Results")

if st.session_state.sessions:
    selected = st.selectbox("Select Session", options=[s["id"] for s in st.session_state.sessions])
    sess = next(s for s in st.session_state.sessions if s["id"] == selected)

    st.subheader(f"Session: {selected}")
    col1, col2 = st.columns(2)
    with col1:
        st.code(sess["secret"], language="text")
        st.text("Original Secret")

    with col2:
        st.code(sess["regen"], language="text")
        st.text("Regenerated by Server")

    st.metric("Entropy", f"{sess['entropy']:.3f}")
    st.metric("Drift", f"{sess['drift']:.2%}")
    st.metric("Anomaly Score", f"{sess['anomaly']:.3f}")
else:
    st.info("Run a session to view data.")

# ======================
# Time Series Plots
# ======================
st.subheader("ðŸ“ˆ Entropy / Anomaly Trends")
if not st.session_state.history.empty:
    st.line_chart(st.session_state.history.set_index("timestamp")[["entropy", "drift", "anomaly"]])

# ======================
# Export
# ======================
st.subheader("ðŸ“¦ Export Session Logs")
if st.button("Download CSV"):
    csv = st.session_state.history.to_csv(index=False).encode("utf-8")
    st.download_button("ðŸ“¥ Download", csv, "warl0k_sessions.csv", "text/csv")
